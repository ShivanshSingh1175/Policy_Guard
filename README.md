# PolicyGuard

**AI-Powered Policy Compliance Platform for Financial Institutions**

Built for GDG Hackfest 2.0 - Policy Compliance Track

---

## Project Overview

PolicyGuard is an intelligent compliance monitoring system designed to help financial institutions automatically detect and manage policy violations in their transaction data. The platform addresses a critical challenge in the financial services industry: ensuring that thousands of daily transactions comply with complex, evolving regulatory policies without requiring manual review of every transaction.

Traditional compliance monitoring relies on manually coded rules that are brittle, hard to maintain, and slow to adapt when policies change. PolicyGuard solves this by using Large Language Models (LLMs) to automatically generate executable MongoDB query rules from natural language policy documents. Compliance officers can upload a policy PDF, and the system extracts the text, interprets the requirements, and generates database queries that can scan transaction data for violations. This dramatically reduces the time from policy update to enforcement, from weeks to minutes.

The platform is built specifically for the GDG Hackfest 2.0 Policy Compliance problem statement and uses the recommended IBM AML (Anti-Money Laundering) dataset as its primary data source. It provides a complete end-to-end solution: policy ingestion, AI-powered rule generation, automated scanning, violation detection, and a web-based console for compliance officers to review and manage findings.

---

## Dataset Usage

### IBM AML Dataset

PolicyGuard uses the **IBM AML dataset** recommended in the GDG Hackfest 2.0 dataset repository. This dataset contains realistic financial transaction data designed for anti-money laundering compliance testing and includes:

- **Transactions**: Individual financial transfers with amounts, sender/receiver accounts, timestamps, and transaction types
- **Accounts**: Customer account information including account types, balances, and risk profiles
- **Customers**: Customer demographic and KYC (Know Your Customer) data
- **Entities**: Business entities involved in transactions

### MongoDB Import Process

The dataset is imported into MongoDB with the following collections:

```
policyguard (database)
‚îú‚îÄ‚îÄ transactions     # Financial transaction records
‚îú‚îÄ‚îÄ accounts         # Account master data
‚îú‚îÄ‚îÄ customers        # Customer profiles and KYC data
‚îú‚îÄ‚îÄ entities         # Business entities
‚îú‚îÄ‚îÄ policies         # Uploaded policy documents
‚îú‚îÄ‚îÄ rules            # AI-generated compliance rules
‚îú‚îÄ‚îÄ scan_runs        # Scan execution history
‚îî‚îÄ‚îÄ violations       # Detected policy violations
```

**Import Steps**:
1. Download IBM AML dataset from the Hackfest GitHub repository
2. Convert CSV files to JSON format (if needed)
3. Use `mongoimport` to load data into respective collections
4. Create indexes on frequently queried fields (account_id, transaction_date, amount, etc.)

### Example Rules Applied to Dataset

PolicyGuard generates and applies various types of compliance rules to the IBM AML dataset:

**1. High-Value Transaction Monitoring**
```json
{
  "name": "Large Cash Transactions Without Documentation",
  "collection": "transactions",
  "query": {
    "$and": [
      {"amount": {"$gt": 10000}},
      {"transaction_type": "CASH"},
      {"documentation_status": {"$ne": "complete"}}
    ]
  },
  "severity": "HIGH"
}
```

**2. Rapid Succession Transfers (Structuring Detection)**
```json
{
  "name": "Multiple Transactions Just Below Reporting Threshold",
  "collection": "transactions",
  "aggregation": [
    {"$match": {"amount": {"$gte": 9000, "$lt": 10000}}},
    {"$group": {
      "_id": "$sender_account",
      "count": {"$sum": 1},
      "total": {"$sum": "$amount"}
    }},
    {"$match": {"count": {"$gte": 3}}}
  ],
  "severity": "CRITICAL"
}
```

**3. Sanctioned Entity Screening**
```json
{
  "name": "Transactions Involving Sanctioned Entities",
  "collection": "transactions",
  "query": {
    "$or": [
      {"sender.sanctioned": true},
      {"receiver.sanctioned": true}
    ]
  },
  "severity": "CRITICAL"
}
```

**4. Unusual Account Activity**
```json
{
  "name": "Dormant Account Sudden Activity",
  "collection": "accounts",
  "query": {
    "$and": [
      {"last_activity_days": {"$gt": 180}},
      {"recent_transaction_count": {"$gt": 5}},
      {"recent_transaction_total": {"$gt": 50000}}
    ]
  },
  "severity": "MEDIUM"
}
```

These rules are automatically generated by the LLM based on policy documents uploaded by compliance officers, then executed against the IBM AML dataset during scheduled or on-demand scans.

---

## Architecture

### System Design

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     Flutter Web Console                         ‚îÇ
‚îÇ  (Dashboard, Policies, Rules, Scans, Violations, Analytics)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ REST API (Dio HTTP Client)
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FastAPI Backend (Uvicorn)                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ  ‚îÇ   Routes     ‚îÇ  ‚îÇ   Services   ‚îÇ  ‚îÇ    Models    ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ (Endpoints)  ‚îÇ  ‚îÇ (Business    ‚îÇ  ‚îÇ  (Pydantic)  ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ  Logic)      ‚îÇ  ‚îÇ              ‚îÇ         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ Motor (Async Driver)
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         MongoDB                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ  ‚îÇ IBM AML Data ‚îÇ  ‚îÇ   Policies   ‚îÇ  ‚îÇ    Rules     ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ (transactions‚îÇ  ‚îÇ   (PDFs)     ‚îÇ  ‚îÇ (Generated)  ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ  accounts,   ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ  customers)  ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ  Scan Runs   ‚îÇ  ‚îÇ  Violations  ‚îÇ                           ‚îÇ
‚îÇ  ‚îÇ  (History)   ‚îÇ  ‚îÇ  (Findings)  ‚îÇ                           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    LLM Service (External)                       ‚îÇ
‚îÇ  Policy Text + Schema ‚Üí AI-Generated MongoDB Rules              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Component Breakdown

**1. Flutter Web Console (Frontend)**
- **Technology**: Flutter 3.x with Material 3 dark theme
- **State Management**: Riverpod for reactive state
- **Routing**: go_router for declarative navigation
- **HTTP Client**: Dio for REST API communication
- **Purpose**: Provides compliance officers with an intuitive interface to manage policies, review violations, and monitor compliance metrics
- **Key Screens**: Dashboard, Policies & Rules, Scans, Violations, Analytics

**2. FastAPI Backend**
- **Technology**: FastAPI with Uvicorn ASGI server
- **Database Driver**: Motor (async MongoDB client)
- **PDF Processing**: PyMuPDF for text extraction
- **Validation**: Pydantic for request/response models
- **Purpose**: Exposes REST APIs for policy management, rule generation, scan execution, and violation tracking
- **Key Services**: 
  - PDF Service: Extracts text from uploaded policy documents
  - LLM Service: Communicates with external LLM to generate rules
  - Scan Service: Executes rules against MongoDB collections and records violations

**3. MongoDB Database**
- **Collections**: 
  - `transactions`, `accounts`, `customers`, `entities` (IBM AML dataset)
  - `policies` (uploaded policy documents with extracted text)
  - `rules` (AI-generated MongoDB queries with metadata)
  - `scan_runs` (execution history with timestamps and results)
  - `violations` (detected violations with status and reviewer notes)
- **Indexes**: Optimized for common queries (by date, amount, account, status, severity)
- **Purpose**: Stores both operational data (AML dataset) and compliance metadata (policies, rules, violations)

**4. LLM Policy Engine**
- **Integration**: External LLM API (OpenAI, Anthropic, or custom)
- **Input**: Policy text + MongoDB schema hints
- **Output**: Structured JSON rule definitions with MongoDB queries
- **Purpose**: Translates natural language policy requirements into executable database queries
- **Example Prompt**: "Given this AML policy text and the schema of the transactions collection, generate MongoDB queries to detect violations"

### Optional Future Enhancements (Roadmap)

- **Event Streaming**: Kafka or Redis Streams for real-time transaction monitoring
- **Vector Database**: Pinecone or Weaviate for semantic policy search and similarity matching
- **Scheduled Scans**: APScheduler or Celery for automated periodic compliance checks
- **Audit Trail**: Immutable log of all policy changes and violation status updates
- **Multi-tenancy**: Support for multiple organizations with isolated data
- **Advanced Analytics**: ML models for anomaly detection and risk scoring

---

## Backend Design

### Folder Structure

```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py              # FastAPI app initialization, CORS, lifespan events
‚îÇ   ‚îú‚îÄ‚îÄ config.py            # Settings from environment variables (Pydantic)
‚îÇ   ‚îú‚îÄ‚îÄ db.py                # MongoDB connection management (Motor)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Pydantic models for request/response
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ policy.py        # PolicyIn, PolicyOut, PolicySummary
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rule.py          # RuleIn, RuleOut, RuleUpdate, RuleSeverity
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan.py          # ScanRequest, ScanRun, ScanSummary
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ violation.py     # Violation, ViolationUpdate, ViolationStatus
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routes/              # API endpoint definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ policies.py      # POST /policies/upload, GET /policies, POST /policies/{id}/extract-rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rules.py         # GET /rules, POST /rules, PATCH /rules/{id}, DELETE /rules/{id}
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scans.py         # POST /scans/run, GET /scans/runs, GET /scans/runs/{id}
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ violations.py    # GET /violations, PATCH /violations/{id}, DELETE /violations/{id}
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ services/            # Business logic and external integrations
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ pdf_service.py   # extract_text_from_pdf(file_bytes) -> str
‚îÇ       ‚îú‚îÄ‚îÄ llm_service.py   # generate_rules_from_policy(text, schema) -> List[RuleIn]
‚îÇ       ‚îî‚îÄ‚îÄ scan_service.py  # run_scan(collections, rule_ids) -> ScanSummary
‚îÇ
‚îú‚îÄ‚îÄ .env                     # Environment variables (not in git)
‚îú‚îÄ‚îÄ .env.example             # Template for environment configuration
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ requirements.txt         # Python dependencies
‚îú‚îÄ‚îÄ run.py                   # Development server runner
‚îî‚îÄ‚îÄ README.md                # Backend-specific documentation
```

### Key API Endpoints

**Policies**
- `POST /policies/upload` - Upload policy PDF, extract text, store in database
  - Request: `multipart/form-data` with file, name, description, version
  - Response: `PolicyOut` with ID, extracted text length, timestamps
- `GET /policies` - List all policies with pagination
  - Query params: `limit`, `offset`
  - Response: `List[PolicySummary]`
- `GET /policies/{id}` - Get policy details including full extracted text
- `POST /policies/{id}/extract-rules` - Use LLM to generate rules from policy
  - Request: `{"schema_hint": "optional MongoDB schema description"}`
  - Response: `List[RuleOut]` with generated rules
- `DELETE /policies/{id}` - Delete policy and associated rules

**Rules**
- `GET /rules` - List rules with filters
  - Query params: `collection`, `enabled`, `policy_id`, `limit`, `offset`
  - Response: `List[RuleOut]`
- `GET /rules/{id}` - Get rule details
- `POST /rules` - Manually create a rule
- `PATCH /rules/{id}` - Update rule (toggle enabled, modify query, change severity)
- `DELETE /rules/{id}` - Delete rule

**Scans**
- `POST /scans/run` - Execute compliance scan
  - Request: `{"collections": ["transactions"], "rule_ids": ["rule_1", "rule_2"]}`
  - Response: `ScanSummary` with violations found, execution time, rule results
- `GET /scans/runs` - List scan history with pagination
- `GET /scans/runs/{id}` - Get detailed scan results
- `DELETE /scans/runs/{id}` - Delete scan run and associated violations

**Violations**
- `GET /violations` - List violations with filters
  - Query params: `rule_id`, `severity`, `status`, `scan_run_id`, `limit`, `offset`
  - Response: `List[Violation]`
- `GET /violations/{id}` - Get violation details with document snapshot
- `PATCH /violations/{id}` - Update violation status and add reviewer notes
  - Request: `{"status": "CONFIRMED", "reviewer_note": "...", "reviewed_by": "officer_name"}`
- `DELETE /violations/{id}` - Delete violation record

### Scan Engine Logic

The scan service (`scan_service.py`) implements the core compliance checking logic:

1. **Load Rules**: Query MongoDB for enabled rules (optionally filtered by collection or rule IDs)
2. **Execute Queries**: For each rule:
   - If rule has a `query` field: Execute `collection.find(query)`
   - If rule has an `aggregation` field: Execute `collection.aggregate(pipeline)`
3. **Record Violations**: For each matching document:
   - Create a violation record with:
     - `scan_run_id`: Links to the current scan
     - `rule_id`: Which rule was violated
     - `document_id`: ID of the violating document
     - `document_data`: Snapshot of the document (sanitized)
     - `severity`: From the rule definition
     - `status`: Initially "OPEN"
     - `created_at`: Timestamp
4. **Update Scan Run**: Record total rules executed, violations found, execution time
5. **Return Summary**: Provide breakdown by rule and overall statistics

---

## Frontend Design

### Main Screens

**1. Dashboard**
- **Purpose**: High-level overview of compliance status
- **Components**:
  - Metric cards: Total violations, open violations, critical issues, active rules
  - Trend charts: Violations over time (line chart), violations by severity (pie chart)
  - Recent violations table: Latest 10 violations with quick actions
- **State**: `dashboardProvider` (FutureProvider) fetches summary from `/dashboard/summary`
- **Interactions**: Click on metric cards to filter violations, click table rows to view details

**2. Policies & Rules**
- **Purpose**: Manage policy documents and generated rules
- **Layout**: Two-column layout
  - **Left Column**: Policy list
    - Shows all uploaded policies with name, version, upload date
    - Click to select and view details
  - **Right Column**: 
    - Upload panel: Drag-and-drop or file picker for PDF upload
    - "Extract Rules" button: Calls LLM to generate rules from selected policy
    - Rules table: Shows all rules for selected policy
      - Columns: Name, Collection, Severity, Enabled (toggle switch), Actions
- **State**: 
  - `policiesProvider` (FutureProvider) fetches from `/policies`
  - `rulesProvider` (FutureProvider) fetches from `/rules`
  - `selectedPolicyProvider` (StateProvider) tracks selected policy
- **Interactions**: 
  - Upload PDF ‚Üí POST to `/policies/upload`
  - Extract rules ‚Üí POST to `/policies/{id}/extract-rules`
  - Toggle rule enabled ‚Üí PATCH to `/rules/{id}`

**3. Scans**
- **Purpose**: Configure and execute compliance scans
- **Components**:
  - Configuration form:
    - Dropdown: Select target collection (or "All collections")
    - Switch: "Only enabled rules"
    - Button: "Run Scan"
  - Scan logs: Real-time text output showing scan progress
  - Scan history table: Past scans with status, timestamp, violations found
- **State**:
  - `scanRunsProvider` (FutureProvider) fetches from `/scans/runs`
  - `isScanningProvider` (StateProvider) tracks scan in progress
- **Interactions**:
  - Run scan ‚Üí POST to `/scans/run`, poll for completion or use WebSocket
  - View scan details ‚Üí Navigate to `/scans/runs/{id}`

**4. Violations**
- **Purpose**: Review and manage detected violations
- **Components**:
  - Filter bar: Dropdowns for severity, status, rule, date range
  - Violations table (DataTable2 with pagination):
    - Columns: Rule Name, Document ID, Severity, Status, Detected At, Actions
    - Row click opens detail panel
  - Detail panel (drawer or modal):
    - Rule name and description
    - Severity badge
    - Document data (key-value pairs)
    - Status dropdown (OPEN, CONFIRMED, DISMISSED, FALSE_POSITIVE)
    - Reviewer note text field
    - Save button
- **State**:
  - `violationsProvider` (FutureProvider) fetches from `/violations`
  - `selectedViolationProvider` (StateProvider) tracks selected violation
- **Interactions**:
  - Apply filters ‚Üí Refresh `violationsProvider` with query params
  - Update status ‚Üí PATCH to `/violations/{id}`

**5. Analytics**
- **Purpose**: Visualize compliance trends and insights
- **Components**:
  - Violations over time (line chart)
  - Violations by collection (pie chart)
  - Violations by severity (bar chart)
  - Top rules by violations (table)
  - Top accounts by violations (table)
- **State**: `analyticsProvider` (FutureProvider) fetches aggregated data
- **Interactions**: Click chart segments to drill down into filtered violations

### Frontend-Backend Communication

- **HTTP Client**: Dio configured in `lib/core/api_client.dart`
- **Base URL**: Configurable in `lib/core/constants.dart` (default: `http://localhost:8000`)
- **State Management**: Riverpod providers for reactive data fetching
- **Error Handling**: Dio interceptors log requests/responses, display user-friendly error messages
- **Loading States**: `AsyncValue` from Riverpod handles loading, data, and error states
- **Mock Data**: Currently, `api_client.dart` returns mock data for development; uncomment actual API calls to connect to backend

---

## Current Status

### ‚úÖ Completed

**Backend**:
- [x] Project structure initialized (`backend/app/` with main.py, config.py, db.py)
- [x] Pydantic models defined for all entities (Policy, Rule, Scan, Violation)
- [x] FastAPI routes implemented for all endpoints (policies, rules, scans, violations)
- [x] MongoDB connection setup with Motor (async driver)
- [x] Database indexes created automatically on startup
- [x] PDF text extraction service implemented (PyMuPDF)
- [x] LLM service stubbed with sample rule generation
- [x] Scan engine implemented (loads rules, executes queries, records violations)
- [x] CORS middleware configured for Flutter frontend
- [x] API documentation auto-generated (Swagger UI at `/docs`)
- [x] Environment configuration with `.env` file
- [x] Development server runner (`run.py`)

**Frontend**:
- [x] Flutter project initialized with Material 3 dark theme
- [x] Riverpod state management configured
- [x] go_router navigation setup with ShellRoute
- [x] Main shell with app bar and sidebar navigation
- [x] Dashboard screen fully implemented with metric cards and tables
- [x] Policies & Rules screen with two-column layout
- [x] Policy list widget with selection
- [x] Policy upload panel with file picker placeholder
- [x] Scans screen with configuration form and history table
- [x] Violations screen with filter bar and table
- [x] Violation detail panel for status updates
- [x] Analytics screen with chart placeholders
- [x] API client with Dio configured and mock data
- [x] Responsive layout (sidebar collapses to drawer on small screens)

**Documentation**:
- [x] Comprehensive README (this file)
- [x] SETUP.md with detailed installation instructions
- [x] QUICKSTART.md for 5-minute setup
- [x] DEBUG.md with troubleshooting guide
- [x] Backend-specific README
- [x] Frontend-specific README

### üöß In Progress

- [ ] IBM AML dataset import scripts (CSV to MongoDB)
- [ ] Real LLM integration (currently returns mock rules)
- [ ] Frontend-backend integration (API calls are stubbed with mock data)
- [ ] Charting library integration (fl_chart or charts_flutter)
- [ ] DataTable2 implementation for paginated tables
- [ ] File picker integration for PDF upload

### üìã Planned

- [ ] Authentication and authorization (JWT tokens)
- [ ] User management (roles: admin, compliance officer, reviewer)
- [ ] Scheduled scans (APScheduler or Celery)
- [ ] Real-time scan progress (WebSocket or Server-Sent Events)
- [ ] Audit trail for all policy and violation changes
- [ ] Export violations to CSV/Excel
- [ ] Email notifications for critical violations
- [ ] Unit tests (pytest for backend, flutter test for frontend)
- [ ] Integration tests
- [ ] Docker Compose for easy deployment
- [ ] CI/CD pipeline (GitHub Actions)

---

## Roadmap / TODO

### Backend

**High Priority**:
1. [ ] Create MongoDB import scripts for IBM AML dataset
   - Download dataset from Hackfest GitHub
   - Write Python script to parse CSV and insert into MongoDB
   - Create indexes on key fields (account_id, transaction_date, amount)
2. [ ] Implement real LLM integration in `llm_service.py`
   - Add OpenAI/Anthropic API client
   - Design prompt template for rule generation
   - Parse LLM response into `RuleIn` objects
   - Add error handling and retry logic
3. [ ] Add authentication middleware
   - JWT token generation and validation
   - Protect endpoints with `Depends(get_current_user)`
   - Add user model and login endpoint
4. [ ] Implement scheduled scans
   - Add APScheduler to run scans periodically
   - Store schedule configuration in database
   - Add endpoints to manage schedules

**Medium Priority**:
5. [ ] Add WebSocket endpoint for real-time scan progress
6. [ ] Implement audit trail (log all changes to policies, rules, violations)
7. [ ] Add export endpoint for violations (CSV/Excel)
8. [ ] Write unit tests for services and routes
9. [ ] Add logging with structured output (JSON logs)
10. [ ] Implement rate limiting and request validation

**Low Priority**:
11. [ ] Add vector database for semantic policy search
12. [ ] Implement ML-based anomaly detection
13. [ ] Add support for multiple LLM providers
14. [ ] Create admin dashboard for system monitoring

### Frontend

**High Priority**:
1. [ ] Connect API client to real backend
   - Uncomment API calls in `api_client.dart`
   - Remove mock data generators
   - Test all endpoints
2. [ ] Integrate charting library (fl_chart)
   - Replace chart placeholders in Dashboard
   - Add interactive charts in Analytics
   - Implement drill-down functionality
3. [ ] Implement DataTable2 for violations and rules
   - Add pagination controls
   - Implement sorting by column
   - Add row selection
4. [ ] Add file picker for PDF upload
   - Integrate `file_picker` package
   - Implement drag-and-drop
   - Show upload progress

**Medium Priority**:
5. [ ] Implement authentication flow
   - Login screen
   - Token storage (secure_storage)
   - Auto-refresh tokens
   - Logout functionality
6. [ ] Add real-time scan progress updates
   - WebSocket connection
   - Live log streaming
   - Progress bar
7. [ ] Implement violation detail panel as drawer
   - Slide-in animation
   - Full document data display
   - Status change confirmation dialog
8. [ ] Add date range picker for filters
9. [ ] Implement export functionality (download violations as CSV)
10. [ ] Write widget tests

**Low Priority**:
11. [ ] Add dark/light theme toggle
12. [ ] Implement keyboard shortcuts
13. [ ] Add accessibility features (screen reader support)
14. [ ] Create mobile-responsive layouts

### AI/Rules

**High Priority**:
1. [ ] Design LLM prompt template for rule generation
   - Include policy text, MongoDB schema, example rules
   - Specify output format (JSON with query/aggregation)
2. [ ] Test LLM with sample policies
   - Validate generated rules
   - Refine prompt based on results
3. [ ] Implement rule validation
   - Check MongoDB query syntax
   - Test rules against sample data
   - Prevent injection attacks

**Medium Priority**:
4. [ ] Add rule templates library
   - Common AML patterns (structuring, smurfing, etc.)
   - Allow users to select and customize templates
5. [ ] Implement rule versioning
   - Track changes to rules over time
   - Allow rollback to previous versions
6. [ ] Add rule testing interface
   - Dry-run rules against sample data
   - Show expected violations before enabling

### DevOps

**High Priority**:
1. [ ] Create Docker Compose setup
   - Backend container
   - Frontend container (nginx)
   - MongoDB container
   - Environment variable configuration
2. [ ] Write deployment documentation
   - Production environment setup
   - Security best practices
   - Backup and restore procedures

**Medium Priority**:
3. [ ] Set up CI/CD pipeline (GitHub Actions)
   - Run tests on pull requests
   - Build and push Docker images
   - Deploy to staging/production
4. [ ] Add monitoring and alerting
   - Prometheus metrics
   - Grafana dashboards
   - Error tracking (Sentry)
5. [ ] Implement database backup strategy
   - Automated daily backups
   - Point-in-time recovery
   - Backup verification

---

## How to Run

### Prerequisites

- **Python 3.11+**: Check with `python --version`
- **Flutter 3.x**: Check with `flutter --version`
- **MongoDB**: Local installation or Docker container
- **Git**: For cloning the repository

### 1. Clone Repository

```bash
git clone <repository-url>
cd policyguard
```

### 2. Setup MongoDB

**Option A: Docker (Recommended)**
```bash
docker run -d -p 27017:27017 --name mongodb mongo:latest
```

**Option B: Local Installation**
- Download from https://www.mongodb.com/try/download/community
- Follow installation instructions for your OS
- Ensure MongoDB is running on port 27017

**Verify MongoDB is running**:
```bash
mongosh mongodb://localhost:27017
# Should connect successfully
```

### 3. Setup Backend

```bash
cd backend

# Create virtual environment
python -m venv venv

# Activate virtual environment
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Configure environment
cp .env.example .env
# Edit .env if needed (default values should work for local development)

# Run backend server
python run.py
```

**Expected output**:
```
INFO:     Uvicorn running on http://0.0.0.0:8000
INFO:     Connected to MongoDB database: policyguard
INFO:     Database indexes created successfully
```

**Verify backend is running**:
- Open http://localhost:8000 in browser (should see `{"service": "PolicyGuard API", "status": "running"}`)
- Open http://localhost:8000/docs for interactive API documentation

### 4. Setup Frontend

```bash
cd frontend

# Install dependencies
flutter pub get

# Run frontend (opens in Chrome automatically)
flutter run -d chrome
```

**Alternative: Use run scripts**
```bash
# Windows
run.bat

# Linux/Mac
chmod +x run.sh
./run.sh
```

**Expected output**:
```
Launching lib/main.dart on Chrome in debug mode...
Building application for the web...
```

**Verify frontend is running**:
- Browser should open automatically with PolicyGuard dashboard
- Check browser console (F12) for any errors
- Navigate through Dashboard, Policies, Scans, Violations, Analytics

### 5. Import IBM AML Dataset (Coming Soon)

```bash
# Download dataset from Hackfest GitHub
# (Script to be implemented)

# Import into MongoDB
python scripts/import_aml_data.py
```

### 6. Test the Application

**Backend Tests**:
```bash
cd backend

# Test health endpoint
curl http://localhost:8000/health

# Test policies endpoint
curl http://localhost:8000/policies

# View API documentation
# Open http://localhost:8000/docs in browser
```

**Frontend Tests**:
- Navigate to Dashboard (should show mock metrics)
- Go to Policies & Rules (should show sample policies)
- Go to Violations (should show sample violations)
- Check browser DevTools Network tab (should see API calls with mock responses)

### Troubleshooting

**Backend won't start**:
- Check Python version: `python --version` (must be 3.11+)
- Ensure MongoDB is running: `mongosh mongodb://localhost:27017`
- Check if port 8000 is available: `netstat -ano | findstr :8000` (Windows) or `lsof -i :8000` (Mac/Linux)
- Install dependencies: `pip install -r requirements.txt`

**Frontend won't start**:
- Check Flutter version: `flutter --version` (must be 3.x)
- Run `flutter doctor` to check for issues
- Clean and reinstall: `flutter clean && flutter pub get`
- Check if Chrome is installed and accessible

**MongoDB connection error**:
- Verify MongoDB is running: `mongosh mongodb://localhost:27017`
- Check `.env` file has correct `MONGO_URI`
- Ensure no firewall blocking port 27017

**For detailed troubleshooting**, see [DEBUG.md](DEBUG.md)

---

## Development Workflow

### Backend Development

```bash
cd backend

# Activate virtual environment
source venv/bin/activate  # or venv\Scripts\activate on Windows

# Run with auto-reload
uvicorn app.main:app --reload --log-level debug

# Run tests (when implemented)
pytest

# Format code
black app/
isort app/

# Type checking
mypy app/
```

### Frontend Development

```bash
cd frontend

# Run with hot reload
flutter run -d chrome

# Hot reload: Press 'r' in terminal
# Hot restart: Press 'R' in terminal

# Analyze code
flutter analyze

# Format code
dart format lib/

# Run tests (when implemented)
flutter test
```

### Database Management

```bash
# Connect to MongoDB shell
mongosh mongodb://localhost:27017/policyguard

# List collections
show collections

# Query transactions
db.transactions.find().limit(5)

# Check indexes
db.transactions.getIndexes()

# Drop database (careful!)
db.dropDatabase()
```

---

## Contributing

This project is built for GDG Hackfest 2.0. Contributions are welcome!

### Development Guidelines

1. **Code Style**:
   - Backend: Follow PEP 8, use Black for formatting
   - Frontend: Follow Dart style guide, use `dart format`
2. **Commits**: Use conventional commits (feat:, fix:, docs:, etc.)
3. **Branches**: Create feature branches from `main`
4. **Pull Requests**: Include description, screenshots (for UI changes), and test results
5. **Testing**: Add tests for new features (when test framework is set up)

### Project Structure Conventions

- Backend: One route file per resource (policies, rules, scans, violations)
- Frontend: Feature-based folder structure (dashboard, policies, scans, violations, analytics)
- Models: Pydantic models in backend, Dart classes in frontend
- Services: Business logic separate from routes/presentation

---

## License

MIT License - See LICENSE file for details

---

## Acknowledgments

- **GDG Hackfest 2.0** for the problem statement and dataset recommendations
- **IBM AML Dataset** for providing realistic financial transaction data
- **FastAPI** and **Flutter** communities for excellent documentation and tools

---

## Contact & Support

For questions, issues, or contributions:
- See [SETUP.md](SETUP.md) for detailed setup instructions
- See [DEBUG.md](DEBUG.md) for troubleshooting
- See [QUICKSTART.md](QUICKSTART.md) for quick start guide

---

**Built with ‚ù§Ô∏è for GDG Hackfest 2.0**
